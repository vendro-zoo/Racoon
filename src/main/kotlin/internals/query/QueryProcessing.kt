package internals.query

import internals.expansions.isInQuotes

object QueryProcessing {
    /**
     * Converts a query with mixed named and indexed parameters to an indexed one only.
     * @param query the query to be converted.
     * @return the converted query, the indexed parameter mappings and the named parameter mappings.
     */
    fun reconstructQuery(query: String): Triple<String, Map<Int, Int>, Map<String, Int>> {
        // Regex to find the parameters in the query
        val indexRegex = Regex("\\?")
        val namedRegex = Regex(":\\w+")

        // Finding only the parameters that are not quoted
        val indexMatches = indexRegex.findAll(query).toList().filter { !query.isInQuotes(it.range.first) }
        val namedMatches = namedRegex.findAll(query).toList().filter { !query.isInQuotes(it.range.first) }

        // Merging the matches into one list
        val matches = (indexMatches + namedMatches).sortedBy { it.range.first }

        // Generating the mapping for the parameters
        val (indexedMapping, namedMapping) = generateParametersMapping(matches)

        // Generating the query without the parameters
        val processedQuery = removeNamedParameters(query, namedMatches)

        return Triple(processedQuery, indexedMapping, namedMapping)
    }

    /**
     * Generates the mapping from the new query to the old query for each parameter.
     * @param matches The list of matches for all the parameters in the query.
     * @return A [Pair] containing the indexed and named mappings.
     */
    private fun generateParametersMapping(matches: List<MatchResult>): Pair<MutableMap<Int, Int>, MutableMap<String, Int>> {
        // Creating the mapping maps to keep track of the correspondence between the new query and the original query
        val indexMapping = mutableMapOf<Int, Int>()
        val namedMapping = mutableMapOf<String, Int>()

        var offset = 0  // Counter of named parameters encountered so far
        var counter = 1  // Counter of the indexed parameters encountered so far (starting from 1)
        for (m in matches) {
            // Checks if is an indexed parameter
            if (m.range.first == m.range.last) {
                indexMapping[counter] = counter + offset
                counter++
            }
            else {
                namedMapping[m.value.substring(1)] = counter + offset
                offset++
            }
        }

        return Pair(indexMapping, namedMapping)
    }

    /**
     * Removes the named parameters from the query and replaces them with a question mark
     * @param query The query to be processed
     * @param namedMatches a list of [MatchResult] objects generated by finding the named parameters in the query
     * @return The query where the named parameters have been replaced with a question mark
     */
    private fun removeNamedParameters(query: String, namedMatches: List<MatchResult>): String {
        // The offset of the namedMatches. This needs to be tracked because the string is modified in the loop.
        var offset = 0

        var q = query
        for (m in namedMatches) {
            // Replace the named parameter with a question mark
            q = q.replaceRange(m.range.first-offset..m.range.last-offset, "?")
            // Update the offset
            offset += m.range.last - m.range.first
        }
        return q
    }
}