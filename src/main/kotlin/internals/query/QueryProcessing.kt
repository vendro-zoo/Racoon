package internals.query

import habitat.racoons.parameters.ParameterMapping
import internals.extensions.isInQuotes

object QueryProcessing {
    /**
     * Converts a query with mixed named and indexed parameters to an indexed one only.
     * @param query the query to be converted.
     * @return the converted query, the indexed parameter mappings and the named parameter mappings.
     */
    fun reconstructQuery(query: String): Pair<String, ParameterMapping> {
        // Regex to find the parameters in the query
        val indexRegex = Regex("\\?")
        val namedRegex = Regex(":\\w+")

        // Finding only the parameters that are not quoted
        val indexMatches = indexRegex.findAll(query).toList().filter { !query.isInQuotes(it.range.first) }
        val namedMatches = namedRegex.findAll(query).toList().filter { !query.isInQuotes(it.range.first) }

        // Merging the matches into one list
        val matches = (indexMatches + namedMatches).sortedBy { it.range.first }

        // Generating the mapping for the parameters
        val mapping = generateParametersMapping(matches)

        // Generating the query without the parameters
        val processedQuery = removeNamedParameters(query, namedMatches)

        return Pair(processedQuery, mapping)
    }

    /**
     * Generates the mapping from the new query to the old query for each parameter.
     * @param matches The list of matches for all the parameters in the query.
     * @return A [Pair] containing the indexed and named mappings.
     */
    private fun generateParametersMapping(matches: List<MatchResult>): ParameterMapping {
        // Creating the mapping to keep track of the correspondence between the new query and the original query
        val parameterMapping = ParameterMapping()

        var offset = 0  // Counter of named parameters encountered so far
        var counter = 1  // Counter of the indexed parameters encountered so far (starting from 1)
        for (m in matches) {
            // Checks if is an indexed parameter
            if (m.range.first == m.range.last) {
                parameterMapping.addIndexed(counter, counter + offset)
                counter++
            }
            else {
                parameterMapping.addNamed(m.value.substring(1), counter + offset)
                offset++
            }
        }

        return parameterMapping
    }

    /**
     * Removes the named parameters from the query and replaces them with a question mark
     * @param query The query to be processed
     * @param namedMatches a list of [MatchResult] objects generated by finding the named parameters in the query
     * @return The query where the named parameters have been replaced with a question mark
     */
    private fun removeNamedParameters(query: String, namedMatches: List<MatchResult>): String {
        // The offset of the namedMatches. This needs to be tracked because the string is modified in the loop.
        var offset = 0

        var q = query
        for (m in namedMatches) {
            // Replace the named parameter with a question mark
            q = q.replaceRange(m.range.first-offset..m.range.last-offset, "?")
            // Update the offset
            offset += m.range.last - m.range.first
        }
        return q
    }
}